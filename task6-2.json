{"camera":{"position":[5.75211883060609e-13,0.6999999999983151,0.7],"target":[0,0.7,0],"nearClipping":0.01,"farClipping":1000,"projection":"Perspective","perspectiveFov":45,"orthographicFov":3},"model":{"mesh":"teapot","position":[0,-8,0],"rotationAxis":[1,0,0],"rotationAngle":0,"scale":[1,1,1],"depthTest":"LESS","faceCulling":"","frontFace":"CCW","showWorldCoordinates":false},"passes":{"Model":{},"Quad":{"R2T":{"shaders":{"vertex":{"source":"//vertex coordinates in world space for the render quad\nattribute vec3 vertex_worldSpace;\n//texture coordinate for this vertex and the render quad\nattribute vec2 textureCoordinate_input;\n\n//texture coordinate needs to be passed on to the R2T fragment shader\nvarying vec2 varyingTextureCoordinate;\n\nuniform mat4 mMatrix;\n//view Matrix\nuniform mat4 vMatrix;\n//projection Matrix\nuniform mat4 pMatrix;\n\nuniform float canvasWidth;\nuniform float canvasHeight;\n\nuniform vec3 cameraPosition;\nuniform mat3 cameraRotation;\n\nuniform bool isOrthographicProjection;\nuniform float orthographicFOV;\nuniform float perspectiveFOV;\n\nvarying vec3 origin;\nvarying vec3 dir;\n\n\n//main program for each vertex of the render quad\nvoid main() {\n\n  float aspectRatio = canvasWidth/canvasHeight;\n  vec3 origin_camSpace, dir_camSpace;\n\n  if (isOrthographicProjection) {\n    origin_camSpace = vec3( vertex_worldSpace.x*orthographicFOV*aspectRatio,\n                            vertex_worldSpace.y*orthographicFOV,\n                            0);\n    dir_camSpace = vec3(0, 0, -1);\n  }\n  else { // perspective projection\n    origin_camSpace = vec3(0);\n    dir_camSpace = vec3(vertex_worldSpace.x*aspectRatio,\n                        vertex_worldSpace.y,\n                        -1.0/tan(radians(perspectiveFOV)));\n  }\n\n  origin = cameraPosition + cameraRotation*origin_camSpace;\n  dir = normalize(cameraRotation*dir_camSpace);\n  gl_Position = vec4(vertex_worldSpace, 1.0);\n\n  varyingTextureCoordinate = textureCoordinate_input;\n}"},"fragment":{"source":"precision mediump float;\n\n// structs ========================================================\nstruct Sphere {\n    vec3 centre;\n    float radius;\n    vec3 colour;\n};\n\nstruct Plane {\n    vec3 point;\n    vec3 normal;\n    vec3 colour;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct Intersection {\n    float t;\n    bool hit;\n    vec3 pos;\n    vec3 normal;\n    vec3 colour;\n};\n\nIntersection initIntersection() {\n    Intersection i;\n    i.pos = vec3(0,0,0);\n    i.normal = vec3(0,0,0);\n    i.colour = vec3(0,0,0);\n    i.hit = false;\n    i.t = -1.0;\n    return i;\n}\n\n// global declarations ============================================\nvarying vec3 origin;\nvarying vec3 dir;\n\n#define PI 3.1415926589793238462643383\nconst float EPSILON = 1e-4;\nconst float MAX_DIST = 10000.0;\nconst int MAXIMUM_RAY_DEPTH = 42;\nconst int NUM_SPHERES = 6;\n\nuniform mat4 mMatrix;\nuniform mat4 vMatrix;\n\n// uniform vec3 lightPosition; // to be controlled by user\nconst int NUM_LIGHTSOURCES = 9;\nvec3 lightPosition[NUM_LIGHTSOURCES];\n\nvec4 ambient = vec4(vec3(0.1), 1.);\nvec4 specular = vec4(1.);\nfloat checkerSpacing = 3.;\nfloat falloff = 0.6; //reflection falloff\n\nfloat k_a = 0.4; //ambient coefficient\nfloat k_d = 0.9; //diffuse coefficient\nfloat k_s = 0.2; //specular coefficient\nfloat s = 600.; //distance heuristic constant\nfloat shininess = 15.; //specular exponent\nfloat phi = 5000.; //light intensity\n\n// SPHERES AND PLANES DECLARATION\nSphere sphere[NUM_SPHERES];\nPlane plane;\n\n// functions ======================================================\nbool castShadowRay(Intersection intersect);\n\nvoid initializeLightPosition(float distribution) {\n    lightPosition[0] = vec3(6,6,4);\n    for (int i=1; i < NUM_LIGHTSOURCES; ++i) {\n        lightPosition[i] = lightPosition[i-1] + distribution;\n    }\n} // light sources in a diagonal line instead of an area for simplicity\n\nfloat rnd() {\n  int seed = int(mod(origin.x*1123.0+619.0, 420.0));\n  return 1./(float(seed)/420.0);\n}\n\nvec3 hitPoint(vec3 origin, vec3 direction, float t) {\n    return origin + t * direction;\n}\n\nvec3 checkerPattern(vec3 pt, vec3 c) {\n    float chessboard = floor(pt.x*checkerSpacing) + floor(pt.z*checkerSpacing);\n    chessboard = (chessboard * 0.5)-floor(chessboard*0.5);\n    if (mod(chessboard, checkerSpacing) == 0.0) {\n        return c;\n    }\n    else return c*0.5;\n}\n\n//DIRECT ILLUMINATION\nvec3 directIllumination(Intersection i, Ray ray) {\n    // soft shadow\n    vec3 lightDir[NUM_LIGHTSOURCES];\n    float distance_av = 0.;\n    for (int j=0; j < NUM_LIGHTSOURCES; j++) {\n        lightDir[j] = vec3(0.);\n        lightDir[j] += lightPosition[j] - i.pos;\n\n        distance_av += length(lightDir[j]) / float(NUM_LIGHTSOURCES);\n\n        lightDir[j] = normalize(lightDir[j]);\n    }\n\n    //ambient ----\n    vec3 ambient_component = k_a * ambient.xyz;\n    //diffuse ----\n    vec3 diffuse_component = vec3(0,0,0);\n    for (int j=0; j < NUM_LIGHTSOURCES; j++) {\n        if (!castShadowRay(i)) {\n            float diff_val = k_d * max(dot(i.normal, lightDir[j]), 0.0);\n            diffuse_component += i.colour * diff_val/float(NUM_LIGHTSOURCES);\n        }\n    }\n    \n    //specular ----\n    vec3 reflect = reflect(lightDir[0], i.normal);\n    float spec_val = k_s * pow((max(dot(normalize(ray.dir), reflect), 0.0)), shininess);\n    vec3 specular_component = specular.xyz * spec_val;\n\n    float d_a = phi / (4.0 * PI * (distance_av + s)); // s is heuristic constant\n    return (ambient_component + diffuse_component + specular_component) * d_a;\n}\n\n// Intersect sphere from lecture notes\nIntersection sphereIntersect(Ray ray, Sphere s) {\n    Intersection i = initIntersection();\n\n    vec3 a = ray.origin - s.centre;\n    float b = dot(ray.dir, a); // d dot deltap    \n    float d = pow(dot(ray.dir, a), 2.0) - pow(length(a), 2.0) + (s.radius * s.radius);\n\n    if(d > 0.0) {\n        float t = -b - sqrt(d); // minimum intersect with the sphere\n        if (t > 0.0){\n            i.hit = true;\n            i.pos = hitPoint(ray.origin, ray.dir, t);\n            i.normal = normalize(i.pos - s.centre);\n\n            // rainbow colored spheres\n            vec3 rainbow = vec3(0.);\n            for (int j = 0; j < 100; j++) {\n                rainbow += i.normal*rnd() / 400.;\n            }\n            rainbow *= s.colour * 3.;\n\n            i.colour = rainbow;\n            i.t = t;\n        }\n    }\n    return i;\n}\n\nIntersection reflectAllSpheres(Ray ray) {\n    Intersection result = initIntersection();\n\n    for (int i = 0; i < NUM_SPHERES; i++) {\n         Intersection currentI = sphereIntersect(ray, sphere[i]);\n         if (currentI.hit)\n             if (!result.hit || currentI.t < result.t) \n                result = currentI;\n    }\n    return result;\n}\n\n// intersect plane from lecture notes\nIntersection planeIntersect(Ray ray) {\n    Intersection result = initIntersection();\n\n    float denom = dot(ray.dir, plane.normal);\n\n    vec3 a = ray.origin - plane.point;\n    float t = -1.0 * (dot(plane.normal, a) / denom);\n    \n    if (t > 0.0 && t < MAX_DIST) {\n        result.hit = true;\n        result.normal = plane.normal;\n        result.pos = hitPoint(ray.origin,ray.dir, t);\n        result.t = t;\n        result.colour = checkerPattern(result.pos, plane.colour);\n    }\n    return result;\n}\n\n// Intersection with all objects\nIntersection intersectAllObjects(Ray ray) {\n    Intersection i_sphere = reflectAllSpheres(ray);\n    Intersection i_plane = planeIntersect(ray);\n\n    if (!i_plane.hit){\n        return i_sphere;\n    } \n    if (!i_sphere.hit) {\n        return i_plane;\n    }\n    if (i_plane.t < i_sphere.t) {\n        return i_plane;\n    }\n    return i_sphere;\n}\n\nint seed = 0;\nfloat rng() {\n  seed = int(mod(float(seed)*1364.0+626.0, 509.0));\n  return 1./(float(seed)/509.0);\n}\n\nbool castShadowRay(Intersection intersect) {\n    // use of rng for soft shadowing\n    vec3 direction = normalize(lightPosition[0]*rng() - intersect.pos*rng());\n    Ray shadowRay;\n    shadowRay.origin = intersect.pos + intersect.normal * EPSILON;\n    shadowRay.dir = direction;\n\n    Intersection shadowIntersect = intersectAllObjects(shadowRay);\n   \n    if (shadowIntersect.hit) return true;\n    return false;\n}\n\nvec3 rayTrace(Ray ray) {\n    float weight = 1.0;\n    vec3 totalColor = vec3(0.0, 0.0, 0.0); //accumulated light intensity\n    for (int i = 0; i < MAXIMUM_RAY_DEPTH; ++i) {\n        Intersection intersection = intersectAllObjects(ray);\n        if (!intersection.hit) break;\n\n        totalColor += directIllumination(intersection, ray) * weight;\n        weight *= falloff; // pow(falloff, float(i));\n        vec3 newDir = normalize(reflect(ray.dir, intersection.normal));\n        Ray reflectedRay;\n        reflectedRay.origin = intersection.pos + intersection.normal*EPSILON;\n        reflectedRay.dir = newDir;\n        \n        ray = reflectedRay;\n    }\n    return totalColor;\n} \n\nvec3 fog(vec3 colour, float dist) {\n    vec3 fog_color = vec3(0.2,0.2,0.4); // adding a purple fog\n    float k_fog = 0.1;\n    float fogAmount = 1. - exp(-dist * k_fog);\n\n    if (dist < 0.0) return fog_color;\n    return mix(colour, fog_color, fogAmount);\n}\n\n// MAIN ========================================================\nvoid main() {\n    // scene definition\n    sphere[0].centre = vec3(-2.0, 1.5, -3.5);\n    sphere[0].radius = 1.5;\n    sphere[0].colour = vec3(0.8,0.8,0.8);\n    sphere[1].centre = vec3(-0.5, 0.0, -2.0);\n    sphere[1].radius = 0.6;\n    sphere[1].colour = vec3(0.3,0.8,0.3);\n    sphere[2].centre = vec3(1.0, 0.7, -2.2);\n    sphere[2].radius = 0.8;\n    sphere[2].colour = vec3(0.3,0.8,0.8);\n    sphere[3].centre = vec3(0.7, -0.3, -1.2);\n    sphere[3].radius = 0.2;\n    sphere[3].colour = vec3(0.8,0.8,0.3);\n    sphere[4].centre = vec3(-0.7, -0.3, -1.2);\n    sphere[4].radius = 0.2;\n    sphere[4].colour = vec3(0.8,0.3,0.3);\n    sphere[5].centre = vec3(0.2, -0.2, -1.2);\n    sphere[5].radius = 0.3;\n    sphere[5].colour = vec3(0.8,0.3,0.8);\n\n    plane.point = vec3(0.0, -0.5, 0.0);\n    plane.normal = vec3(0, 1.0, 0);\n    plane.colour = vec3(1, 1, 1);\n\n    Ray ray;\n    ray.dir = normalize((mMatrix* vec4(dir, 0.)).xyz);\n    ray.origin = origin;\n    // scene definition end\n\n    // Soft shadows\n    initializeLightPosition(0.1); // 0.1 spacing between each of the light sources\n\n    //RAYTRACE\n    vec3 finalColor = rayTrace(ray);\n\n    // fog\n    Intersection i = intersectAllObjects(ray);\n    float dist = -1.;\n    if(i.hit) {\n        dist = length(hitPoint(ray.origin, ray.dir, i.t) - ray.origin);\n    }\n\n    finalColor = fog(finalColor, dist);\n    gl_FragColor = vec4(finalColor,1.);\n}"}},"uniforms":{"value":{"mMatrix":{"attachment":"Model Matrix"},"vMatrix":{"attachment":"View Matrix"},"pMatrix":{"attachment":"Projection Matrix"},"canvasWidth":{"attachment":"Canvas Width"},"canvasHeight":{"attachment":"Canvas Height"},"cameraPosition":{"attachment":"Camera Position"},"cameraRotation":{"attachment":"Camera Rotation"},"isOrthographicProjection":{"attachment":"Orthographic Projection?"},"orthographicFOV":{"attachment":"Orthographic FOV"},"perspectiveFOV":{"attachment":"Perspective FOV"}}}}}},"output":{"image":"Quad/R2T Pass color"}}