{"camera":{"position":[0,0.7,0.7],"target":[0,0.7,0],"nearClipping":0.01,"farClipping":1000,"projection":"Perspective","perspectiveFov":45,"orthographicFov":3},"model":{"mesh":"teapot","position":[0,-8,0],"rotationAxis":[1,0,0],"rotationAngle":0,"scale":[1,1,1],"depthTest":"LESS","faceCulling":"","frontFace":"CCW","showWorldCoordinates":false},"passes":{"Model":{},"Quad":{"R2T":{"shaders":{"vertex":{"source":"// From the spec\nattribute vec4 vertex_worldSpace;\n\nuniform float canvasWidth;\nuniform float canvasHeight;\nuniform vec3 cameraPosition;\nuniform mat3 cameraRotation;\nuniform bool isOrthographicProjection;\nuniform float orthographicFOV;\nuniform float perspectiveFOV;\n\nvarying vec3 origin;\nvarying vec3 dir;\n\nvoid main() {\n    float aspectRatio = canvasWidth/canvasHeight;\n    vec3 origin_camSpace, dir_camSpace;\n\n    if (isOrthographicProjection) {\n        origin_camSpace = vec3(vertex_worldSpace.x*orthographicFOV*aspectRatio,\n                               vertex_worldSpace.y*orthographicFOV, \n                               0);\n        dir_camSpace = vec3(0, 0, -1);\n    }\n    else { // perspective projection\n        origin_camSpace = vec3(0);\n        dir_camSpace = vec3(vertex_worldSpace.x*aspectRatio,\n                            vertex_worldSpace.y,\n                            -1.0/tan(radians(perspectiveFOV)));\n    }\n\n    origin = cameraPosition + cameraRotation*origin_camSpace;\n    dir = normalize(cameraRotation*dir_camSpace);\n    gl_Position = vertex_worldSpace;\n}\n"},"fragment":{"source":"precision mediump float;\n\n// structs ========================================================\nstruct Sphere {\n    vec3 centre;\n    float radius;\n    vec3 colour;\n};\nstruct Plane {\n    vec3 point;\n    vec3 normal;\n    vec3 colour;\n};\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\nstruct Intersection {\n    float t;\n    bool hit;\n    vec3 pos;\n    vec3 normal;\n    vec3 colour;\n};\n\n// Intersection initialization\nIntersection initIntersection() {\n    Intersection i;\n    i.pos = vec3(0,0,0);\n    i.normal = vec3(0,0,0);\n    i.colour = vec3(0,0,0);\n    i.hit = false;\n    i.t = -1.0;\n    return i;\n}\n\n// global declarations ============================================\nvarying vec3 origin;\nvarying vec3 dir;\n\n#define PI 3.1415926589793238462643383\nconst float EPSILON = 1e-4;\nconst float MAX_DIST = 10000.0;\nconst int MAXIMUM_RAY_DEPTH = 42;\nconst int NUM_OF_SPHERES = 6;\n\nuniform mat4 mMatrix;\nuniform mat4 vMatrix;\nuniform vec3 lightPosition; // to be controlled by user\n\nvec4 ambient = vec4(vec3(0.1), 1.);\nvec4 specular = vec4(1.);\nfloat checkerSpacing = 3.;\nfloat falloff = 0.6; //reflection falloff\n\nfloat k_a = 0.4; //ambient coefficient\nfloat k_d = 0.9; //diffuse coefficient\nfloat k_s = 0.2; //specular coefficient\nfloat s = 600.; //distance heuristic constant\nfloat shininess = 15.; //specular exponent\nfloat phi = 5000.; //light intensity\n\n// SPHERES AND PLANES DECLARATION\nSphere sphere[NUM_OF_SPHERES];\nPlane plane;\n\n// functions ======================================================\nbool castShadowRay(Intersection intersect);\n\nvec3 hitPoint(vec3 origin, vec3 direction, float t) {\n    return t * direction + origin;\n}\n\nvec3 checkerPattern(vec3 pt, vec3 c) {\n    float chessboard = floor(pt.x*checkerSpacing) + floor(pt.z*checkerSpacing);\n    chessboard = (chessboard * 0.5)-floor(chessboard*0.5);\n    if (mod(chessboard, checkerSpacing) == 0.0) {\n        return c;\n    }\n    else return c*0.5;\n}\n\nvec3 directIllumination(const Intersection i, const Ray ray) {\n    vec3 lightDir = lightPosition - i.pos;\n    float dist = length(lightDir);\n    lightDir = normalize(lightDir);\n\n    //ambient ----\n    vec3 ambient_component = k_a * ambient.xyz;\n    //diffuse ----\n    vec3 diffuse_component = vec3(0,0,0);\n    if (!castShadowRay(i)) {\n        float diff_val = k_d * max(dot(i.normal, lightDir), 0.0);\n        diffuse_component = i.colour * diff_val;\n    }\n    //specular ----\n    vec3 reflect = reflect(lightDir, i.normal);\n    float spec_val = k_s * pow((max(0.,dot(normalize(ray.dir), reflect))), shininess);\n    vec3 specular_component = specular.xyz * spec_val;\n\n    float d_a = phi / (4.0 * PI * (dist + s)); // s is heuristic constant\n    return (ambient_component + diffuse_component + specular_component) * d_a;\n}\n\n// Intersect sphere from lecture notes\nIntersection sphereIntersect(Ray ray, Sphere s) {\n    Intersection i = initIntersection();\n\n    vec3 a = ray.origin - s.centre;\n    float b = dot(ray.dir, a); // d dot deltap    \n    float d = pow(dot(ray.dir, a), 2.0) - pow(length(a), 2.0) + (s.radius * s.radius);\n\n    if(d > 0.0) {\n        float t = -b - sqrt(d); // minimum intersect with the sphere\n        if (t > 0.0){\n            i.hit = true;\n            i.pos = hitPoint(ray.origin, ray.dir, t);\n            i.normal = normalize(i.pos - s.centre);\n            i.colour = s.colour;\n            i.t = t;\n        }\n    }\n    return i;\n}\n\nIntersection reflectAllSpheres(Ray ray) {\n    Intersection result = initIntersection();\n\n    for (int i = 0; i < NUM_OF_SPHERES; i++) {\n         Intersection currentI = sphereIntersect(ray, sphere[i]);\n         if (currentI.hit)\n             if (!result.hit || currentI.t < result.t) \n                result = currentI;\n    }\n    return result;\n}\n\n// Intersect plane from lecture notes\nIntersection planeIntersect(Ray ray) {\n    Intersection result = initIntersection();\n\n    float d = dot(ray.dir, plane.normal);\n\n    vec3 a = ray.origin - plane.point;\n    float t = -1.0 * (dot(plane.normal, a) / d);\n    \n    if (t > 0.0 && t < MAX_DIST) {\n        result.hit = true;\n        result.normal = plane.normal;\n        result.pos = hitPoint(ray.origin,ray.dir, t);\n        result.t = t;\n        result.colour = checkerPattern(result.pos, plane.colour);\n    }\n\n    return result;    \n}\n\n// Intersection with all objects\nIntersection intersectAllObjects(Ray ray) {\n    Intersection i_sphere = reflectAllSpheres(ray);\n    Intersection i_plane = planeIntersect(ray);\n\n    if (!i_plane.hit){\n        return i_sphere;\n    } \n    if (!i_sphere.hit) {\n        return i_plane;\n    }\n    if (i_plane.t < i_sphere.t) {\n        return i_plane;\n    }\n    return i_sphere;\n}\n\nbool castShadowRay(Intersection intersect) {\n    vec3 direction = normalize(lightPosition - intersect.pos);\n    Ray shadowRay;\n    shadowRay.origin = intersect.pos + intersect.normal * EPSILON;\n    shadowRay.dir = direction;//normalize((mMatrix* vec4(lightPosition, 0.0)).xyz);\n\n    Intersection shadowIntersect = intersectAllObjects(shadowRay);\n   \n    if (shadowIntersect.hit) return true;\n    return false;\n}\n\nvec3 rayTrace(Ray ray) {\n    float weight = 1.0;\n    vec3 totalColor = vec3(0.0, 0.0, 0.0); //accumulated light intensity\n    for (int i = 0; i < MAXIMUM_RAY_DEPTH; ++i) {\n        Intersection intersection = intersectAllObjects(ray);\n        if (!intersection.hit) break;\n\n        totalColor += directIllumination(intersection, ray) * weight;\n        weight *= falloff; // pow(falloff, float(i));\n        vec3 newDir = normalize(reflect(ray.dir, intersection.normal));\n        Ray reflectedRay;\n        reflectedRay.origin = intersection.pos + intersection.normal*EPSILON;\n        reflectedRay.dir = newDir;\n         \n        ray = reflectedRay;\n    }\n    return totalColor;\n}\n\n// MAIN ========================================================\nvoid main() {\n    // scene definition\n    sphere[0].centre = vec3(-2.0, 1.5, -3.5);\n    sphere[0].radius = 1.5;\n    sphere[0].colour = vec3(0.8,0.8,0.8);\n    sphere[1].centre = vec3(-0.5, 0.0, -2.0);\n    sphere[1].radius = 0.6;\n    sphere[1].colour = vec3(0.3,0.8,0.3);\n    sphere[2].centre = vec3(1.0, 0.7, -2.2);\n    sphere[2].radius = 0.8;\n    sphere[2].colour = vec3(0.3,0.8,0.8);\n    sphere[3].centre = vec3(0.7, -0.3, -1.2);\n    sphere[3].radius = 0.2;\n    sphere[3].colour = vec3(0.8,0.8,0.3);\n    sphere[4].centre = vec3(-0.7, -0.3, -1.2);\n    sphere[4].radius = 0.2;\n    sphere[4].colour = vec3(0.8,0.3,0.3);\n    sphere[5].centre = vec3(0.2, -0.2, -1.2);\n    sphere[5].radius = 0.3;\n    sphere[5].colour = vec3(0.8,0.3,0.8);\n\n    plane.point = vec3(0.0, -0.5, 0.0);\n    plane.normal = vec3(0, 1.0, 0);\n    plane.colour = vec3(1, 1, 1);\n\n    Ray ray;\n    ray.dir = normalize((mMatrix* vec4(dir, 0.)).xyz);\n    ray.origin = origin;\n    // scene definition end\n\n    //RAYTRACE\n    vec3 finalColor = rayTrace(ray);\n\n    gl_FragColor = vec4(finalColor,1.);\n}"}},"uniforms":{"value":{"canvasWidth":{"attachment":"Canvas Width"},"canvasHeight":{"attachment":"Canvas Height"},"cameraPosition":{"attachment":"Camera Position"},"cameraRotation":{"attachment":"Camera Rotation"},"isOrthographicProjection":{"attachment":"Orthographic Projection?"},"orthographicFOV":{"attachment":"Orthographic FOV"},"perspectiveFOV":{"attachment":"Perspective FOV"},"mMatrix":{"attachment":"Model Matrix"},"vMatrix":{"attachment":"View Matrix"},"lightPosition":{"value":[6,4,3]}}}}}},"output":{"image":"Quad/R2T Pass color"}}